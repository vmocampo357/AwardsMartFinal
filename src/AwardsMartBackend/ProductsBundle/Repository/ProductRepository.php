<?php

namespace AwardsMartBackend\ProductsBundle\Repository;
use AwardsMartBackend\ProductsBundle\Data\ProductSearchCriteria;
use AwardsMartBackend\ProductsBundle\Entity\ProductImage;
use Doctrine\ORM\Query\Expr;
use Doctrine\ORM\QueryBuilder;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * ProductRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductRepository extends \Doctrine\ORM\EntityRepository
{

    public $query = "";

    /**
     * @param ProductSearchCriteria $criteria
     * @param int $page
     * @param int $limit
     * @return Paginator
     *
     * Returns a Paginator, using the filtered..stuff.
     */
    public function findProductsByCriteriaPaginated(ProductSearchCriteria $criteria, $page = 1, $limit = 5)
    {
        /** @var QueryBuilder $qb */ // The false prevents it from selecting other..things.
        $qb = $this->buildCriteriaCall($criteria, false);
        $qb->addOrderBy("p.name","ASC");
        
        return $this->paginate($qb->getQuery(), $limit, $page);
    }

    /**
     * @param ProductSearchCriteria $criteria
     * @return array
     *
     * Use the criteria call to build a search for API
     */
    public function findProductsByCriteria(ProductSearchCriteria $criteria)
    {
        /** @var QueryBuilder $qb */
        $qb = $this->buildCriteriaCall($criteria);

        $this->query = $qb->getQuery()->getSQL();

        # Limit: We can limit these to about 100 results, the top ones
        // $qb->groupBy("p.id");
        $qb->setFirstResult(0);
        $qb->setMaxResults(500);

        $pre_result = $qb->getQuery()->getArrayResult();
        $result = [];
        foreach( $pre_result as $r ){
            $key = 'Product_'.$r['id'];
            if( !isset($result[$key])){
                $result[$key] = array(
                    'link' => $r['id'],
                    'name' => $r['name'],
                    'price' => $r['price'],
                    'image' => $r['source']
                );
            }
        }
        return $result;
    }

    /**
     * @param ProductSearchCriteria $criteria
     * @return \Doctrine\ORM\Query
     *
     * Uses criteria to build a DQL Query
     */
    public function buildCriteriaCall(ProductSearchCriteria $criteria, $api = true)
    {
        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder();
        $qb->select('p');

        // Select specifics if this is for API
        if($api){
            $qb->addSelect('p.name')
                ->addSelect("p.id")
                ->addSelect("z.price")
                ->addSelect("i.source");
        }

        $qb ->from("ProductsBundle:Product", "p")
            ->join("p.categories","c")
            ->join("p.productSizes","s")
            ->join("s.prices","z")
            ->join("p.productImages","i")
            ->where($qb->expr()->eq("i.role",":role"))
            ->andWhere($qb->expr()->eq("z.min",":min"));

        if($api || $criteria->isActive()) // If we're using the API, we automatically always want Active products
            $qb->andWhere("p.isActive = 1");

        if(!$criteria->isActive())
            $qb->andWhere("p.isActive = 0");

        # Sets the quantity for the MIN we're looking for on price
        # Products with minimums higher than 1 are excluded from search
        $qb->setParameter("min", 1);
        $qb->setParameter("role",ProductImage::THUMBNAIL_ROLE);

        # Criteria: Multiple Category IDs
        if( $criteria->getByCategoryId() && !empty($criteria->getByCategoryId()) ){
            $qb->andWhere( $qb->expr()->in("c.id",":categories"));
            $qb->setParameter("categories", $criteria->getByCategoryId());
        }

        # Criteria: General Text Search
        if( $criteria->getByText() && !empty($criteria->getByText()) ){
            $or_where = $qb->expr()->orX();
            $or_where->add( $qb->expr()->like("p.name",":general") );
            /*$or_where->add( $qb->expr()->like("p.description",":general") );*/
            $or_where->add( $qb->expr()->like("p.sku",":general") );
            // $or_where->add( $qb->expr()->like("p.metaDescription",":general") );
            $qb->setParameter("general", "%" . $criteria->getByText() . "%");
            $qb->andWhere( $or_where );
        }

        # Criteria: Size Min
        if( $criteria->getByPriceMin() && $criteria->getByPriceMin() != 0){
            $qb->andWhere( $qb->expr()->gte("z.price", ":minPrice"));
            $qb->setParameter("minPrice", $criteria->getByPriceMin());
        }

        # Criteria: Size Max
        if( $criteria->getByPriceMax() && $criteria->getByPriceMax() != 0){
            $qb->andWhere( $qb->expr()->lte("z.price", ":maxPrice"));
            $qb->setParameter("maxPrice", $criteria->getByPriceMax());
        }

        # Criteria: SKU Specifically
        if( $criteria->getBySku() && !empty($criteria->getBySku()) ){
            $qb->orWhere( $qb->expr()->like("p.sku",":sku") );
            $qb->setParameter("sku", $criteria->getBySku());
        }

        # Criteria: Max ID (since there are so many records, we limit how many load up front)
        if( $criteria->isByMaxId() ){
            $qb->andWhere($qb->expr()->lte("p.id",800));
        }

        # Criteria: Sort BY
        if( $criteria->getSortBy() && !empty($criteria->getSortBy()) ){
            $sort_by = intval( $criteria->getSortBy() );
            switch( $sort_by ){
                case(ProductSearchCriteria::SORT_ASC_PRICE):
                    $qb->addOrderBy("z.price","ASC");
                    break;
                case(ProductSearchCriteria::SORT_DESC_PRICE):
                    $qb->addOrderBy("z.price","DESC");
                    break;
                case(ProductSearchCriteria::SORT_ASC_PRODUCT_NAME):
                    $qb->addOrderBy("p.name","ASC");
                    break;
                case(ProductSearchCriteria::SORT_DESC_PRODUCT_NAME):
                    $qb->addOrderBy("p.name","DESC");
                    break;
            }
        }

        return $qb;
    }

    /**
     * @param $dql
     * @param int $limit
     * @param int $page
     * @return Paginator
     *
     * This will create a Paginator instance with the right info.
     */
    public function paginate($dql, $limit = 5, $page = 1)
    {
        $paginator = new Paginator($dql);

        $paginator->getQuery()
            ->setFirstResult($limit * ($page - 1)) // Offset
            ->setMaxResults($limit); // Limit

        return $paginator;
    }
}
